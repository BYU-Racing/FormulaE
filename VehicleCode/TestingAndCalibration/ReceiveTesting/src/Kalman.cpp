// #include <iostream>
// #include "C:\Users\dalli\source\repos\BYURacing\eigen-3.4.0\Eigen\Dense"
// #include <Eigen/Dense>  // Eigen library for matrix operations
// #include <random>       // For generating random numbers
// #include <fstream>
// #include <vector>
// #include <string>


// using namespace Eigen;

// class KalmanFilter {
// private:
//     MatrixXd F, Q, H, R, G;
//     VectorXd u;

// public:
//     KalmanFilter(MatrixXd _F, MatrixXd _Q, MatrixXd _H, MatrixXd _R, MatrixXd _G, VectorXd _u)
//         : F(_F), Q(_Q), H(_H), R(_R), G(_G), u(_u) {}

//     /**
//      * Compute the first N states and observations generated by the Kalman system
//      *
//      * @param x0 Initial state as a vector of shape (n,)
//      * @param N The number of time steps to evolve
//      * 
//      * @return A tuple containing two matrices:
//      *         - states: A matrix of shape (n, N) where each column represents the i-th state
//      *         - obs: A matrix of shape (m, N) where each column represents the i-th observation
//      */
//     std::tuple<MatrixXd, MatrixXd> evolve(VectorXd x0, int N) {
//         // initialize the sizes
//         int n = x0.size();
//         int m = H.rows();

//         // initialize the output
//         MatrixXd states(n, N), obs(m, N);
//         states.col(0) = x0;
//         obs.col(0) = x0.head(2);

//         std::default_random_engine generator;
//         std::normal_distribution<double> distribution(0.0, 1.0);

//         // iterate to compute the states and observations
//         for (int i = 1; i < N; ++i) {
//             VectorXd state_noise = VectorXd::Zero(n);
//             VectorXd obs_noise = VectorXd::Zero(m);

//             // Generate noise
//             for (int j = 0; j < n; ++j)
//                 state_noise(j) = distribution(generator);

//             for (int j = 0; j < m; ++j)
//                 obs_noise(j) = distribution(generator);

//             states.col(i) = F * states.col(i - 1) + G * u + state_noise;
//             obs.col(i) = H * states.col(i) + obs_noise;
//         }

//         return std::make_tuple(states, obs);
//     }


//     /**
//      * Compute the state estimates using the Kalman filter
//      *
//      * @param x0 Initial state estimate as a vector of shape (n,)
//      * @param P0 Initial error covariance matrix of shape (n, n)
//      * @param z Sequence of observations with shape (m, N), where N is the number of observations
//      *          Each column represents an observation
//      * 
//      * @return Sequence of state estimates with shape (n, N), where N is the number of observations
//      *         Each column represents an estimate
//      */
//     MatrixXd estimate(VectorXd x0, MatrixXd P0, MatrixXd z) {
//         int n = x0.size();
//         int N = z.cols();

//         // initialize the output
//         MatrixXd output(n, N);
//         output.col(0) = x0;
//         VectorXd xk1 = x0;
//         MatrixXd pk1 = P0;

//         // iterate to compute the state estimates
//         for (int i = 1; i < N; ++i) {
//             // Prediction step
//             VectorXd xk = F * xk1 + G * u;
//             MatrixXd pk = F * pk1 * F.transpose() + Q;

//             // Update step
//             VectorXd yh = z.col(i) - H * xk;
//             MatrixXd Sk = H * pk * H.transpose() + R;
//             MatrixXd Kk = pk * H.transpose() * Sk.inverse();
//             xk = xk + Kk * yh;
//             pk = (MatrixXd::Identity(n, n) - Kk * H) * pk;

//             output.col(i) = xk;

//             // Update the state
//             xk1 = xk;
//             pk1 = pk;
//         }

//         return output;
//     }


//     /**
//      * Predict the next k states in the absence of observations
//      *
//      * @param x The current state estimate as a vector of shape (n,)
//      * @param k The number of states to predict
//      * 
//      * @return A matrix of shape (n, k) containing the next k predicted states
//      */
//     MatrixXd predict(VectorXd x, int k) {
//         int n = x.size();
//         MatrixXd out(n, k);

//         // iterate to compute the state estimates
//         for (int i = 0; i < k; ++i) {
//             VectorXd out_i = F * x + G * u;
//             out.col(i) = out_i;
//             x = out_i;
//         }

//         return out;
//     }


//     /**
//      * Predict the states from time 0 through k-1 in the absence of observations
//      *
//      * @param x The state estimate at time k as a vector of shape (n,)
//      * @param k The current time step
//      * 
//      * @return A matrix of shape (n, k) containing the predicted states from time 0 up through k-1
//      *         Each column represents a predicted state at a specific time step
//      */
//     MatrixXd rewind(VectorXd x, int k) {
//         int n = x.size();
//         MatrixXd out(n, k);

//         for (int i = 0; i < k; ++i) {
//             VectorXd out_i = (F.inverse() * (x - G * u)).eval();
//             out.col(i) = out_i;
//             x = out_i;
//         }

//         return out;
//     }
// };




// int main() {
//     // Define matrices and vectors
//     double dt = 0.1;
//     double qScale = 0.1;
//     double rScale = 1000;
//     MatrixXd Q = MatrixXd::Identity(9, 9) * qScale;
//     MatrixXd R = MatrixXd::Identity(6, 6) * rScale;

//     MatrixXd F = MatrixXd::Identity(9, 9);
//     F.topRightCorner(3, 6).fill(0.1);
//     F.block<3, 3>(0, 3) = MatrixXd::Identity(3, 3) * dt;

//     MatrixXd G = MatrixXd::Ones(9, 9);
//     VectorXd x0 = VectorXd::Zero(9);
//     MatrixXd P0 = MatrixXd::Identity(9, 9) * 1e5;

//     MatrixXd H(6, 9);
//     H.setZero();
//     for (int i = 0; i < 3; ++i) {
//         H(i, i) = 1;
//         H(i + 3, i + 6) = 1;
//     }

//     VectorXd u = VectorXd::Zero(9);
    
//     // Load data from CSV file for z
//     std::ifstream file("data.csv");
//     std::vector<std::vector<double>> data;
//     std::string line;
//     while (std::getline(file, line)) {
//         std::istringstream iss(line);
//         std::vector<double> row;
//         double value;
//         while (iss >> value) {
//             row.push_back(value);
//         }
//         data.push_back(row);
//     }
//     file.close();
//     int numRows = data.size();
//     int numCols = data[0].size();
//     MatrixXd z(numCols, numRows);
//     for (int i = 0; i < numRows; ++i) {
//         for (int j = 0; j < numCols; ++j) {
//             z(j, i) = data[i][j];
//         }
//     }

//     // Initialize KalmanFilter object
//     KalmanFilter kf(F, Q, H, R, G, u);
//     MatrixXd est = kf.estimate(x0, P0, z);

//     /** est
//      * 0 = x position
//      * 1 = y position
//      * 2 = z position
//      * 6 = x acceleration
//      * 7 = y acceleration
//      * 8 = z acceleration
//     */

//     return 0;
// }

